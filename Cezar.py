### CEZAR ###

# coздаем списки алфавитов
EN_alf = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
# Nikita: ты можешь создать один массив из другого с помощью toLower - меньше дублирования
en_alf = 'abcdefghijklmnopqrstuvwxyz'
# Nikita: alf не очень понятное сокращение. Вообще лучше, конечно, использовать английские слова - так твой код будет понятен всем, его легко будет пошарить в гитхабе. Да и вооьще выглядит лучше, так как ключевые слова все равно английские
# Nikita: лучше не завязываться на регистр в идентификаторах, просто опиши это словами: alphabet_upper_ru. Почему? Такие имена очень плохо различаются визуально. Тебе нужно помнить, что есть два (и не дай бог больше двух) варианта. Если они всегда используются рядом - с этим можно жить, но если они в разных частях кода - это очень трудно отслеживать. В общем, просто лучше так не делать
RU_alf = 'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ'
ru_alf = 'абвгдежзийклмнопрстуфхцчшщъыьэюя'

# пользовательский блок
# Nikita: коммент к коментарию - почему это пользовательский блок? Имеется в виду блок ввода данных?
print('Введите sh, если хотите шифровать. Введите dsh, если хотите дешифровать')
# Nikita: type_shifr - либо использую только русские слова, либо только английские. Причем везде, во всем коде. Комбинирование подходов делает идентификаторы бессмысленными, все равно что a, b, foo etc
type_shifr = input()
# Nikita: я бы рекомендовал принимать аргументы через параметры командной строки: > cezar sh ru "привет, как дела?" - это общепринятая и всем понятная практика. 
if type_shifr != 'sh' and type_shifr != 'dsh':  # проверка корректности ввода действия
    print('Ошибка ввода! Поробуйте снова!')
    exit(0)

print('Введите ru, если хотите использовать русский язык. Введите en, если хотите использовать английский язык')
# Nikita: ln - непонятный идентификатор, лучше было бы user_input_language, соответственно type_shifr можно было бы назвать user_input_action
ln = input()
# Nikita: представь, что тебе нужно добавить поддержку еще одного языка. В скольких местах предется изменить программу? Идеально, если только в одном - добавить новый массив символов. Это возможно в данном случае, и такой рефакторинг сделает программу в разы проще и короче.
if ln != 'ru' and ln != 'en':  # проверка корректности ввода языка
    # Nikita: сообщение об ошибке повторяется в коде более одного раза. Любой код, который повторяется, нужно выносить в функцию: print_validation_error()
    print('Ошибка ввода! Поробуйте снова!')
    exit(0)

print('Введите шаг сдвига')
# Nikita: снова нейминг (самая сложная задача в программировании). Если соблюдать концепцию, которую я описал выше, получится user_input_step - сразу видно, что ввел юзер
step = input()
if step.isdigit() != True:  # проверка корректности ввода шага
    print('Ошибка ввода! Поробуйте снова!')
    exit(0)
# Nikita: да, так можно в python, но это плохая практика. Если меняешь тип данных - объяви новую переменную. Это просто и дешево: step = int(user_input_step)
step = int(step) # однозначное опредление шага числом

print('Введите текст')
text = input()


# задаем мощность алфавита
# Nikita: снова к вопросу о добавлении поддержки еще одного языка...
if ln == 'en':
    # Nikita: непонятное имя. Не бойся длинных имен, программа становится длиннее, но в разы понятнее
    n = len(en_alf)
elif ln == 'ru':
    n = len(ru_alf)

# Nikita: снова имя. Было бы лучше selected_language_and_text_mismatch
# Nikita: почему флаг установлен в true? ты изначально предполагаешь, что ошибка есть
er = True # флаг ошибки (устанавливается False в случае если задан русский язык, а введен текст на английском языке и наоборот)
# Nikita: i - нормальный иеднтификатор в данном случае. Для циклов норм
for i in range(len(text)):
    # Nikita: строки 58 и 60 выполняют одинаковую логику, но различаются парамтерами - этот код стоит вынести в функцию: validate(ln, RU_alf, ru_alf)
    if ln == 'en' and ((text[i] in RU_alf)  or  (text[i] in ru_alf)):
        er = False
    elif ln == 'ru' and ((text[i] in EN_alf)  or  (text[i] in en_alf)):
        er = False
# Nikita: тут явно инверсия логики. er == True я читаю как "есть ошибка (error - true)", но логика использования говорит об обратном
if er == False:
    print('Ошибка ввода! Поробуйте снова!')
    exit(0)

# основной блок
# Nikita: тут самое интересное - количество дублирования равно <количество операций> * <количество поддерживаемых языков>
if type_shifr == 'sh':
    if ln == 'en': # блок  ШИФРОВАНИЯ на английском языке
        for i in range(len(text)):
            b = []
            if text[i] in EN_alf:
                # Nikita: блоки для EN_alf и en_alf различаются только параметром - необходимо ввынести в функцию (это уже уберет 4! дублирующихся блока)
                a = EN_alf.find(text[i])
                k = (a + step) % n
                b = EN_alf[k]
            elif text[i] in en_alf:
                a = en_alf.find(text[i])
                k = (a + step) % n
                b = en_alf[k]
                # Nikita: что если пользователь ввел знак @ или еще что-то? 
            elif text[i] in '0123456789 !?,.':
                b = text[i]
            print(*b, end='')

    elif ln == 'ru': # блок ШИФРОВАНИЯ на русском языке
        for i in range(len(text)):
            b = []
            if text[i] in RU_alf:
                a = RU_alf.find(text[i])
                k = (a + step) % n
                b = RU_alf[k]
            if text[i] in ru_alf:
                a = ru_alf.find(text[i])
                k = (a + step) % n
                b = ru_alf[k]
            if text[i] in '0123456789 !?,.':
                b = text[i]
            print(*b, end='')

elif type_shifr == 'dsh':
    if ln == 'en': # блок ДЕШИФРОВАНИЯ на английском языке
        for i in range(len(text)):
            b = []
            if text[i] in EN_alf:
                a = EN_alf.find(text[i])
                k = (a - step) % n
                b = EN_alf[k]
            elif text[i] in en_alf:
                a = en_alf.find(text[i])
                k = (a - step) % n
                b = en_alf[k]
            elif text[i] in '0123456789 !?,.':
                b = text[i]
            print(*b, end='')

    elif ln == 'ru': # блок ДЕШИФРОВАНИЯ на русском языке
        for i in range(len(text)):
            b = []
            if text[i] in RU_alf:
                a = RU_alf.find(text[i])
                k = (a - step) % n
                b = RU_alf[k]
            elif text[i] in ru_alf:
                a = ru_alf.find(text[i])
                k = (a - step) % n
                b = ru_alf[k]
            elif text[i] in '0123456789 !?,.':
                b = text[i]
            print(*b, end = '')


